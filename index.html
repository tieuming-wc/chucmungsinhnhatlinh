<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Ch√≠t M·ªõt CNTT7</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Segoe UI', sans-serif;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }

        #ui-layer {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }

        .guide {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px black;
            background: rgba(0, 0, 0, 0.6);
            display: inline-block;
            padding: 15px 30px;
            border-radius: 15px;
            line-height: 1.8;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        button {
            pointer-events: auto;
            cursor: pointer;
            background: linear-gradient(to bottom, #D32F2F, #8B0000);
            color: #FFF;
            border: 2px solid #FFD700;
            padding: 15px 50px;
            border-radius: 30px;
            font-weight: 800;
            font-size: 16px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
            animation: pulse 1.5s infinite;
            display: block;
            margin: 0 auto;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        #camera-preview {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 160px;
            height: 120px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            transform: scaleX(-1);
            opacity: 0.8;
            border-radius: 10px;
            background: #000;
        }

        #copyright {
            position: absolute;
            bottom: 5px;
            right: 15px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            z-index: 100;
            font-family: sans-serif;
            pointer-events: none;
            font-style: italic;
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <div class="guide">
            ‚ù§Ô∏è <b>2 Hands (Heart):</b> Love<br>
            ‚úä <b>Fist:</b> Tree &nbsp;|&nbsp; üñê <b>Open:</b> Explode &nbsp;|&nbsp; üëå <b>Pinch:</b> Photo<br>
            üëç <b>Thumb Up:</b> Gift &nbsp;|&nbsp; ‚òùÔ∏è <b>1 Finger:</b> Universe &nbsp;|&nbsp; &nbsp;|&nbsp; ü§ò
            <b>Rock:</b> Lion
        </div>
        <button id="btnStart" onclick="startSystem()">START MAGIC</button>
    </div>

    <div id="copyright">¬© Thay Duong DZ</div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display:none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
        const MUSIC_URL = "./audio.mp3";
        let bgMusic = new Audio(MUSIC_URL);
        bgMusic.loop = true; bgMusic.volume = 1.0;

        const loader = new THREE.TextureLoader();
        const photoFiles = [
            './20251217-140734.082-1.jpg',
            './20251217-140734.082-2.jpg',
            './20251217-140734.082-3.jpg',
            './20251217-140734.082-4.jpg',
            './20251217-140734.082-5.jpg',
            './20251217-140734.082-6.jpg',
        ];
        const photoTextures = [];
        photoFiles.forEach((f, i) => photoTextures[i] = loader.load(f));

        function createCustomTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const cx = 32, cy = 32;

            const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
            if (type === 'gold_glow') {
                grd.addColorStop(0, '#FFFFFF'); grd.addColorStop(0.4, '#FFD700'); grd.addColorStop(1, 'rgba(0,0,0,0)');
            } else if (type === 'red_light') {
                grd.addColorStop(0, '#FFAAAA'); grd.addColorStop(0.4, '#FF0000'); grd.addColorStop(1, 'rgba(0,0,0,0)');
            } else if (type === 'gift') {
                grd.addColorStop(0, '#AAFFAA'); grd.addColorStop(0.4, '#00FF00'); grd.addColorStop(1, 'rgba(0,0,0,0)');
            }
            ctx.fillStyle = grd; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        const textures = {
            gold: createCustomTexture('gold_glow'),
            red: createCustomTexture('red_light'),
            gift: createCustomTexture('gift')
        };

        const CONFIG = {
            goldCount: 2200,
            redCount: 400,
            giftCount: 200,
            treeHeight: 70,
            treeBaseRadius: 35
        };

        let scene, camera, renderer;
        let groupGold, groupRed, groupGift;
        let photoMeshes = [];
        let titleMesh, starMesh, loveMesh, cntt7Mesh;

        let state = 'TREE';
        let selectedIndex = 0;

        // --- SHAPE MATH ---
        function getCNTT7Point() {
            if (!window.CNTT7_POINTS || window.CNTT7_POINTS.length === 0) {
                const text = "HAPPY BIRTH DAY";
                const cvs = document.createElement('canvas');
                const W = 1024, H = 256; cvs.width = W; cvs.height = H;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = 'black'; ctx.fillRect(0, 0, W, H);
                const fontSize = 170;
                ctx.fillStyle = 'white'; ctx.font = `bold ${fontSize}px Times New Roman`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(text, W / 2, H / 2 + 10);

                const img = ctx.getImageData(0, 0, W, H).data;
                const pts = [];
                const sample = 6; // lower -> denser
                for (let y = 0; y < H; y += sample) {
                    for (let x = 0; x < W; x += sample) {
                        const i = (y * W + x) * 4 + 3; // alpha
                        if (img[i] > 128) {
                            const nx = (x - W / 2) / (W / 2) * 60; // scale X
                            const ny = (H / 2 - y) / (H / 2) * 20; // scale Y
                            pts.push({ x: nx, y: ny });
                        }
                    }
                }
                if (pts.length === 0) pts.push({ x: 0, y: 0 });
                window.CNTT7_POINTS = pts;
            }
            const arr = window.CNTT7_POINTS;
            const p = arr[Math.floor(Math.random() * arr.length)];
            return { x: p.x + (Math.random() - 0.5) * 2, y: p.y + (Math.random() - 0.5) * 2, z: (Math.random() - 0.5) * 2 };
        }

        function getLionPoint() {
            const r = Math.random();
            let x, y, z;
            if (r < 0.6) {
                const ang = Math.random() * Math.PI * 2;
                const rad = 20 + Math.random() * 15;
                x = Math.cos(ang) * rad; y = Math.sin(ang) * rad; z = (Math.random() - 0.5) * 10;
            } else if (r < 0.9) {
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const rad = 18 * Math.pow(Math.random(), 0.3);
                x = rad * Math.sin(phi) * Math.cos(theta);
                y = rad * Math.sin(phi) * Math.sin(theta);
                z = rad * Math.cos(phi) + 5;
            } else {
                if (Math.random() > 0.5) { x = (Math.random() > 0.5 ? 8 : -8) + (Math.random() - 0.5) * 2; y = 5; z = 20; }
                else { x = 0; y = -5; z = 22; }
            }
            return { x, y, z };
        }

        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.0);
            groupRed = createParticleSystem('red', CONFIG.redCount, 3.5);
            groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.0);

            createPhotos();
            createDecorations();
            animate();
        }

        function createParticleSystem(type, count, size) {
            const pPositions = [];
            const pTree = [], pHeart = [], pExplode = [], pGift = [], pUniverse = [], pCNTT7 = [], pLion = [];
            const sizes = [], phases = [];

            for (let i = 0; i < count; i++) {
                // Tree
                const h = Math.random() * CONFIG.treeHeight;
                const r = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius * ((type === 'gold') ? Math.sqrt(Math.random()) : 0.9 + Math.random() * 0.1);
                const theta = Math.random() * Math.PI * 2;
                pTree.push(r * Math.cos(theta), h - CONFIG.treeHeight / 2, r * Math.sin(theta));

                // Heart
                const tH = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(tH), 3), hy = 13 * Math.cos(tH) - 5 * Math.cos(2 * tH) - 2 * Math.cos(3 * tH) - Math.cos(4 * tH);
                const rFill = Math.pow(Math.random(), 0.3);
                pHeart.push(hx * rFill * 2.2, hy * rFill * 2.2 + 5, (Math.random() - 0.5) * 10);

                // Explode
                const phi = Math.acos(2 * Math.random() - 1), lam = Math.random() * Math.PI * 2;
                const rad = 65 * Math.cbrt(Math.random());
                pExplode.push(rad * Math.sin(phi) * Math.cos(lam), rad * Math.sin(phi) * Math.sin(lam), rad * Math.cos(phi));

                // Gift
                const side = 40, axis = Math.floor(Math.random() * 3);
                let gx = (Math.random() - 0.5) * side, gy = (Math.random() - 0.5) * side, gz = (Math.random() - 0.5) * side;
                if (axis === 0) gx = (Math.random() > 0.5 ? 1 : -1) * side / 2; else if (axis === 1) gy = (Math.random() > 0.5 ? 1 : -1) * side / 2; else gz = (Math.random() > 0.5 ? 1 : -1) * side / 2;
                pGift.push(gx * (0.9 + Math.random() * 0.2), gy * (0.9 + Math.random() * 0.2), gz * (0.9 + Math.random() * 0.2));

                // Universe
                const arm = i % 3, spin = Math.random() * 3 * Math.PI, dist = spin * 5;
                pUniverse.push(Math.cos(spin + (Math.PI * 2 / 3) * arm) * dist, (Math.random() - 0.5) * (100 - dist) / 5, Math.sin(spin + (Math.PI * 2 / 3) * arm) * dist);

                // CNTT7 & Lion
                const ptC = getCNTT7Point(), ptL = getLionPoint();
                pCNTT7.push(ptC.x, ptC.y, ptC.z); pLion.push(ptL.x, ptL.y, ptL.z);

                pPositions.push(pTree[i * 3], pTree[i * 3 + 1], pTree[i * 3 + 2]);
                sizes.push(size); phases.push(Math.random() * Math.PI * 2);
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const colors = new Float32Array(count * 3);
            const baseColor = new THREE.Color(type === 'gold' ? 0xFFD700 : (type === 'red' ? 0xFF0000 : 0xFFFFFF));
            for (let i = 0; i < count; i++) { colors[i * 3] = baseColor.r; colors[i * 3 + 1] = baseColor.g; colors[i * 3 + 2] = baseColor.b; }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            geo.userData = {
                tree: pTree, heart: pHeart, explode: pExplode, gift: pGift, universe: pUniverse, cntt7: pCNTT7, lion: pLion,
                phases: phases, baseColor: baseColor, baseSize: size
            };

            const mat = new THREE.PointsMaterial({
                size: size, map: textures[type], transparent: true, opacity: 1.0,
                vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true
            });
            scene.add(new THREE.Points(geo, mat));
            return scene.children[scene.children.length - 1];
        }

        function createPhotos() {
             const geo = new THREE.PlaneGeometry(8, 8);
            for (let i = 0; i < 5; i++) {
                const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide }));
                mesh.visible = false; mesh.scale.set(0, 0, 0);
                scene.add(mesh); photoMeshes.push(mesh);
            }
        }

        function createDecorations() {
            function txtTex(t, s, c) {
                const cvs = document.createElement('canvas'); cvs.width = 1024; cvs.height = 256;
                const ctx = cvs.getContext('2d'); ctx.font = `bold italic ${s}px "Times New Roman"`; ctx.fillStyle = c;
                ctx.textAlign = 'center'; ctx.shadowColor = "#FFF"; ctx.shadowBlur = 20; ctx.fillText(t, 512, 150);
                return new THREE.CanvasTexture(cvs);
            }
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), new THREE.MeshBasicMaterial({ map: txtTex("MERRY CHRISTMAS", 90, '#FFD700'), transparent: true, blending: THREE.AdditiveBlending }));
            titleMesh.position.set(0, 50, 0); scene.add(titleMesh);

            const starCvs = document.createElement('canvas'); starCvs.width = 128; starCvs.height = 128;
            const sCtx = starCvs.getContext('2d'); sCtx.fillStyle = "#FFFF00"; sCtx.shadowColor = "#FFF"; sCtx.shadowBlur = 20;
            sCtx.beginPath();
            for (let i = 0; i < 5; i++) {
                sCtx.lineTo(64 + Math.cos((18 + i * 72) / 180 * Math.PI) * 50, 64 - Math.sin((18 + i * 72) / 180 * Math.PI) * 50);
                sCtx.lineTo(64 + Math.cos((54 + i * 72) / 180 * Math.PI) * 20, 64 - Math.sin((54 + i * 72) / 180 * Math.PI) * 20);
            }
            sCtx.closePath(); sCtx.fill();
            starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(starCvs), transparent: true, blending: THREE.AdditiveBlending }));
            starMesh.position.set(0, CONFIG.treeHeight / 2 + 2, 0); scene.add(starMesh);

            loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), new THREE.MeshBasicMaterial({ map: txtTex("I LOVE YOU ‚ù§Ô∏è", 100, '#FF69B4'), transparent: true, blending: THREE.AdditiveBlending }));
            loveMesh.position.set(0, -20, 20); loveMesh.visible = false; scene.add(loveMesh);

            cntt7Mesh = new THREE.Mesh(new THREE.PlaneGeometry(50, 12), new THREE.MeshBasicMaterial({ map: txtTex("CNTT7 - K17", 100, '#00FFFF'), transparent: true, blending: THREE.AdditiveBlending }));
            cntt7Mesh.position.set(0, -30, 0); cntt7Mesh.visible = false; scene.add(cntt7Mesh);
        }

        function updateParticleGroup(group, targetState, speed, time) {
            const attr = group.geometry.attributes;
            const positions = attr.position.array, colors = attr.color.array, sizes = attr.size.array;
            const u = group.geometry.userData;

            let key = 'tree';
            if (targetState === 'HEART') key = 'heart';
            else if (targetState === 'EXPLODE' || targetState === 'PHOTO') key = 'explode';
            else if (targetState === 'GIFT') key = 'gift';
            else if (targetState === 'UNIVERSE') key = 'universe';
            else if (targetState === 'CNTT7') key = 'cntt7';
            else if (targetState === 'LION') key = 'lion';

            const targets = u[key];
            for (let i = 0; i < positions.length; i++) positions[i] += (targets[i] - positions[i]) * speed;
            attr.position.needsUpdate = true;

            // Rotation & Effects
            if (targetState === 'UNIVERSE') { group.rotation.y -= 0.002; group.rotation.z = Math.sin(time * 0.5) * 0.2; }
            else if (targetState === 'GIFT') { group.rotation.y += 0.01; group.rotation.x = Math.sin(time) * 0.1; }
            else if (targetState === 'TREE') { group.rotation.y += 0.005; group.rotation.x = 0; group.rotation.z = 0; }
            else { group.rotation.y *= 0.95; group.rotation.x *= 0.95; group.rotation.z *= 0.95; }

            const count = positions.length / 3;
            for (let i = 0; i < count; i++) {
                let b = 0.8 + 0.4 * Math.sin(time * (key === 'explode' ? 15 : 5) + u.phases[i]);
                if (targetState === 'HEART' || targetState === 'CNTT7') b = 1.0;
                colors[i * 3] = u.baseColor.r * b; colors[i * 3 + 1] = u.baseColor.g * b; colors[i * 3 + 2] = u.baseColor.b * b;
                sizes[i] = u.baseSize;
            }
            attr.color.needsUpdate = true; attr.size.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001, speed = 0.06;
            updateParticleGroup(groupGold, state, speed, time);
            updateParticleGroup(groupRed, state, speed, time);
            updateParticleGroup(groupGift, state, speed, time);

            titleMesh.visible = (state === 'TREE'); starMesh.visible = (state === 'TREE');
            loveMesh.visible = (state === 'HEART'); cntt7Mesh.visible = (state === 'CNTT7');

            if (state === 'EXPLODE') {
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;
                    const a = time * 0.5 + (i * (Math.PI * 2 / 5));
                    mesh.position.set(Math.cos(a) * 30, Math.sin(time + i) * 5, Math.sin(a) * 30);
                    mesh.lookAt(camera.position); mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                });
            } else if (state === 'PHOTO') {
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;
                    if (i === selectedIndex) {
                        mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1); mesh.scale.lerp(new THREE.Vector3(6, 6, 6), 0.1);
                        mesh.lookAt(camera.position); mesh.rotation.z = 0;
                    } else mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                });
            } else photoMeshes.forEach(m => { m.visible = false; m.scale.set(0, 0, 0); });

            renderer.render(scene, camera);
        }

        function startSystem() {
            document.getElementById('btnStart').style.display = 'none';
            bgMusic.play().catch(e => console.log(e));
            init3D();

            const video = document.getElementsByClassName('input_video')[0];
            const canvas = document.getElementById('camera-preview');
            const ctx = canvas.getContext('2d');

            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

            hands.onResults(results => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

                if (results.multiHandLandmarks.length === 0) { state = 'TREE'; return; }

                // 1. Two Hands Check -> HEART
                if (results.multiHandLandmarks.length === 2) {
                    const h1 = results.multiHandLandmarks[0], h2 = results.multiHandLandmarks[1];
                    const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                    const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                    if (distIndex < 0.15 && distThumb < 0.15) { state = 'HEART'; return; }
                }

                // 2. One Hand Logic
                const lm = results.multiHandLandmarks[0];

                // Finger States (Open if Tip Y < PIP Y) - Note: Y is inverted in screen coords? No, 0 is top.
                // So if tip is higher (smaller y) than pip, it's extended.
                const isExt = (tip, pip) => lm[tip].y < lm[pip].y;

                const idx = isExt(8, 6), mid = isExt(12, 10), ring = isExt(16, 14), pinky = isExt(20, 18);
                // Thumb is special: Check horizontal distance or if it's "above" the palm center?
                // Simple Thumb Up: Thumb Tip is highest point (min Y) of thumb.
                // Or check if Thumb Tip Y < Index MCP Y for "Thumb Up".
                const thumbUp = lm[4].y < lm[5].y;

                // A. Pinch (Photo)
                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                if (pinchDist < 0.05 ) {
                    state = 'PHOTO';
                    selectedIndex = Math.floor(lm[9].x * 5) % 5; // Rotate photos by hand position
                    return;
                }

                // B. Gestures based on extensions
                // Fist: No fingers extended
                if (!idx && !mid && !ring && !pinky && !thumbUp) { state = 'TREE'; return; }

                // Open: All extended
                if (idx && mid && ring && pinky) { state = 'EXPLODE'; return; }

                // Point: Only Index
                if (idx && !mid && !ring && !pinky) { state = 'UNIVERSE'; return; }

                // Victory: Index & Middle
                if (idx && mid && !ring && !pinky) { state = 'CNTT7'; return; }

                // Rock: Index & Pinky
                if (idx && !mid && !ring && pinky) { state = 'LION'; return; }

                // Thumb Up: Only Thumb (and maybe index curled)
                // Relaxed: Thumb is up, others are down.
                if (thumbUp && !idx && !mid && !ring && !pinky) { state = 'GIFT'; return; }

                // Default fallbacks to avoid sticking
                // If somewhat closed -> Tree
                // If somewhat open -> Explode
            });

            const cameraUtils = new Camera(video, {
                onFrame: async () => { await hands.send({ image: video }); }, width: 320, height: 240
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            if (camera) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        });
    </script>
</body>

</html>